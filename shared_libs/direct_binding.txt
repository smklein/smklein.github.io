TODO(this isn't really about direct binding anymore)
TODO(kind of a mess, questions don't match. Good CLI dynlinking tho)

~~~ HOW EXACTLY ARE SYMBOLS IMPORTED FROM SHARED LIBRARIES?

They're imported by the dynamic linker.

~~~ RIGHT, BUT HOW CAN EXECUTABLES BE COMPILED WITH UNDEFINED STRONG SYMBOLS?

You have to do some header / command line magic.

Suppose we have some files:

hello.c
  #include <stdio.h>
  #include "shared.h"
  int main(void) { printf("Foo: %d\n", get_five()); return 0; }

shared.c
  #include "shared.h"
  int get_five() { return 5; }

shared.h
  #ifndef SHARED_H_
  #define SHARED_H_
  int get_five();
  #endif

Then we can build these with:
  clang -shared -fPIC -nostdlib shared.c -o shared.so
  clang hello.c -l:shared.so -o hello
  export LD_LIBRARY_PATH=.
  ./hello

We'll end up with two ELF objects "shared.so" and "hello".
TODO(explain why -fPIC / -nostdlib (optional) / -shared)

Using "nm -g shared.so", we can see all exported symbols from this shared
library. In this list, we can see:

  000000000000002e0 T get_five

Hey! It's the definition of our function.

~~~ COOL! BUT HOW DOES THE "hello" BINARY KNOW WHERE "get_five" IS?

Good question, me! Think about this for a moment. It's sort of a bizzare
situation -- yeah, we're dynamically linking get_five(), but before we even
get into the nitty gritty details of "how exactly do we change our binary to
point to the real get_five?", we need to know what shared object it lives in.

Do we search every 'so' in our system? Ask the user for input? Or something
else?

For strong symbols, we'll need to keep a record of the fact that we depend
on a library named "shared.so".

If you run "readelf -d hello", meaning "please show me dynamic-linking related
info for the hello binary", we can see the dynamic section.

This includes the line:
  0x0000000000000001 (NEEDED)       Shared library: [shared.so]

Neat! So our dynamic linker, at runtime, will know to run off and look for
undefined symbols in shared.so, thanks to this entry, known as a "DT_NEEDED"
entry.

TODO(good opportunity to talk about GNU_HASH at some point)

~~~ DIRECT BINDING

For Linux's dynamic linker, DT_NEEDED entries are used to generate the list of
shared libraries where unresolved symbols might live.

~~~ OKAY. SO WHAT IF WE HAVE HUNDREDS OF SHARED LIBRARIES THAT WE DEPEND ON?

Then looking for a symbol means looking through hundreds of shared libraries.

TODO(lazy loading of symbols?)

~~~ WAIT A SECOND.

Yeah?

~~~ IF I TRIED TO COMPILE "hello" WITH "clang hello.c -o hello", IT GIVES ME AN
UNDEFINED REFERENCE TO "get_five".

Yup.

~~~ THAT MEANS THAT WHEN WE INCLUDED "-l:shared.so", THE LINKER KNEW WHICH
SHARED OBJECT THE SYMBOL LIVES IN!

... and?

~~~ IF WE KNEW WHERE THE SYMBOL WAS BEFORE, WHY DO WE NEED TO LOOK FOR IT AGAIN?

Congratulations, you've just re-invented a concept called "direct binding".
This is a feature of the linker on Solaris and OpenSolaris, where at link time,
the linker makes new ELF section filled with pairs of "symbol : DT_NEEDED
entry". This way, the dynamic linker can just directly look for the desired
symbol in one ".so".

~~~ OH. DOES DIRECT BINDING WORK ON LINUX TOO?

TODO(-Bdirect ? I actually don't totally know)

https://lwn.net/Articles/192624/

Seems Ulrich didn't like it...

https://sourceware.org/ml/binutils/2005-10/msg00437.html

~~~ OH. WHY DOESN'T EVERYONE USE DIRECT BINDING? IT SEEMS GREAT.

TODO( downside? 





